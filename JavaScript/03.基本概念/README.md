# 3. 基本概念

- [3.1 语法](#31-语法)
    - [3.1.1 区分大小写](#311-区分大小写)
    - [3.1.2 标识符](#312-标识符)
    - [3.1.3 注释](#313-注释)
    - [3.1.4 严格模式](#314-严格模式)
    - [3.1.5 语句](#315-语句)
- [3.2 关键字和保留字](#32-关键字和保留字)
- [3.4 数据类型](#34-数据类型)
    - [3.4.1 typeof 操作符](#341-typeof-操作符)
    - [3.4.2 Undefined类型](#342-undefined类型)
    - [3.4.3 Null类型](#343-null类型)
    - [3.4.4 Boolean类型](#344-boolean类型)
    - [3.4.5 Number类型](#345-number类型)
    - [3.4.6 String类型](#346-string类型)
    - [3.4.7 Object类型](#347-object类型)
- [3.5 操作符](#35-操作符)
    - [3.5.1 一元操作符](#351-一元操作符)
    - [3.5.2 位操作符](#352-位操作符)
    - [3.5.3 布尔操作符](#353-布尔操作符)
    - [3.5.4 乘性操作符](#354-乘性操作符)
    - [3.5.5 加性操作符](#355-加性操作符)
    - [3.5.6 关系操作符](#356-关系操作符)
    - [3.5.7 相等操作符](#357-相等操作符)
    - [3.5.8 条件操作符](#358-条件操作符)
    - [3.5.9 赋值操作符](#359-赋值操作符)
    - [3.5.10 逗号操作符](#3510-逗号操作符)
- [3.6 语句](#36-语句)
    - [3.6.1 if语句](#361-if语句)
    - [3.6.2 do-while语句](#362-do-while语句)
    - [3.6.3 while语句](#363-while语句)
    - [3.6.4 for语句](#364-for语句)
    - [3.6.5 for-in语句](#365-for-in语句)
    - [3.6.6 label语句](#366-label语句)
    - [3.6.7 break和continue语句](#367-break和continue语句)
    - [3.6.8 with语句](#368-with语句)
    - [3.6.9 switch 语句](#369-switch-语句)
- [3.7 函数](#37-函数)
    - [3.7.1 理解函数](#371-理解函数)
    - [3.7.2 没有重载](#372-没有重载)
- [3.8 小结](#38-小结)



## 3.1 语法

### 3.1.1 区分大小写

### 3.1.2 标识符

所谓**标识符**，就是指变量、函数、属性的名字，或者函数的参数

标识符的组合规则如下：

- 第一个字符必须是一个**字母**、**下划线（_）**或一个**美元符号（$）**；
- 其他字符可以是**字母**、**下划线**、**美元符号**或**数字**。 

### 3.1.3 注释

```
// 单行注释

/*
 *
 * 多行注释
 *
 */
```
### 3.1.4 严格模式
`ECMAScript 5` 引入了严格模式（`strict mode`）的概念, 是为 `JavaScript` 定义了一种不同的 解析与执行模型。在严格模式下，`ECMAScript 3` 中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误

要在整个脚本中启用严格模式，可以在顶部添加如下代码:
```
"use strict"; 
```
### 3.1.5 语句
- `ECMAScript` 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾
- 虽然条件控制语句（如 `if` 语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句


## 3.2 关键字和保留字

`ECMA-262`描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是 `ECMAScript` 的全部关键字（带`*`号上标的是第 5版新增的关键字）： 

  -| -| -| -
 :---|:---|:---|:---
break |do |instanceof  |typeof
case | else | new |var
catch| finally| return|void 
continue|for| switch|while 
debugger* | function  | this |with
default |  if  |  throw| delete 
in  | try       

 `ECMA-262`还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定 的用途，但它们有可能在将来被用作关键字。以下是 `ECMA-262`第3版定义的全部保留字
-| -| -| -
:---|:---|:---|:---
 abstract | enum |int | short 
 boolean |export |interface |static 
 byte |extends |long |super
 char |final  |native  |ynchronized 
 class  | floa |  package  |throws 
 const  | goto |  private  |  transient 
 debugger  |implements  |protected |volatile 
 double  |import  |public    

 在实现 `ECMAScript 3`的 `JavaScript`引擎中使用关键字作标识符，会导致“`Identifier Expected`”错误。 

 ## 3.3 变量
- ` ECMAScript` 的变量是**松散型**的， 即可以用来**保存任何类型的数据**， 换句话说， 每个变量仅仅是一个**用于保存值的占位符**而已
- 可以在修改变量值的同时修改变量的类型
- 使用`var`操作符定义的变量将成为定义该变量的**作用域**中的局部变量， 如果在函数中使用 `var` 定义了一个变量， 这个变量将在函数退出时销毁
- 省略 `var` 操作符定义变量， 将创建全局变量

## 3.4 数据类型
`ECMAScript` 中有 5 种**简单数据类型**(也称**基本数据类型**)
- Undefined
- Null
- String
- Number
- Boolean
还有 1 种复杂数据类型：
- Object
`Object` 本质上是由一组**无序名值对**组成的

所有值最终都将是上述6种数据类型之一

### 3.4.1 typeof 操作符

检测给定变量的数据类型, 可能返回下列某个字符串
- "`undefined`"——如果这个值未定义
- "`boolean`"——如果这个值是布尔值
- "`string`"——如果这个值是字符串； 
- "`number`"——如果这个值是数值
- "`object`"——如果这个值是对象或 `null`
- "`function`"——如果这个值是函数。 

`typeof` 是一个 **操作符** 而不是函数, 因此 圆括号 不是必须的

### 3.4.2 Undefined类型
- `Undefined` 类型只有一个值，即特殊的 `undefined` 。在使用 `var` 声明变量但未对其加以初始化时， 这个变量的值就是 `undefined`
- 第 3 版引入这个值是为了正式区分**空对象指针**与**未经初始化的变量**


### 3.4.3 Null类型
`Null`类型只有一个值：`null`; 从逻辑角度来看， `null`值 表示一个**空对象指针**， 而这也正是使用 `typeof` 操作符检测 `null` 值时会返回"`object`"的原因

- 如果定义的变量准备在将来用来保存对象， 那么最好将该变量初始化为 null 而不是其他值
- 实际上， `undefined` 值是派生自 `null` 值的， 因此 `ECMA-262` 规定对他们进行相等性测试时要返回 `true`
```
null == undefined   // true
```
### 3.4.4 Boolean类型
该类型有 2 个字面值： true 和 false, 这两个值与数字值不是一回事，因此 `true` 不一定等于 `1`，而 `false` 也不一定等于 `0`。

- 虽然 Boolean 类型的字面值只有两个，但 `ECMAScript` 中所有类型的值都有与这两个 `Boolean` 值 等价的值。要将一个值转换为其对应的 Bool`ean 值，可以调用转型函数 `Boolean()`

### 3.4.5 Number类型

- 最基本的数字字面量是十进制
- 八进制字面值第一位必须为0， 然后是 0~7 如果超出范围， 前导 0 将被忽略
- `NaN`: 
    - 非数值， 但 `typeof(NaN) = Number`;
    - 任何数除以 0 都是 `NaN`
    - 判断是否是 `NaN` : isNaN()
- 数值转换
    - `Number()`
        - 如果是 `Boolean` ， `true` 和 `false` 将分别被转换为 `1` 和 `0`
        - 如果是数值， 返回数值
        - 如果是 `null` 返回 `0` 
        - 如果是 `undefined` 返回 `NaN`
        - 如果是字符串
            - 只包含数字： 转为十进制数字
            - 包含有效的浮点格式， 转为浮点数值
            - 包含有效十六进制， 转为十六进制
            - 空串， 转为 `0` 
            - 其余情况转为 `NaN`
    - `parseInt()`
        - 它会忽略字符串前面的空格， 直到找到第一个非空字符串
        - 如果第一个数字不是数字字符或者正负号， 返回 `NaN`
        - 转换空串也会返回 `NaN`
        - 如果第一个是数字， 继续解析第二个， 直到解析完所有或遇到一个非数字字符
        - parseInt() 可以传递第二个参数来指定转换时使用的基数
    - `parseFloat()`
        - 类似于 `parseInt()`
        - 字符串中第一个小数点是有效的

### 3.4.6 String类型
- 字符串的特点
    ECMAScript 中的字符串是不可变的， 字符串一旦创建， 它的值就不可改变。 要改变某个变量保存的字符串， 首先要销毁原来的字符串， 然后再用一个包含新值的字符串填充该变量

### 3.4.7 Object类型

Object的每个实例都具有下列属性和方法：
- `constructor`: 保存着用于创建当前对象的函数（构造函数）
- `hasOwnProperty(propertyName)`: 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在
- `isPropotypeOf(object)`： 用于检查传入的对象是否是传入对象的原型（原型在05章讨论）
- `propertyIsEnumerable(propertyName)`: 用于检查给定的属性是否能够用 `for-in` 来枚举
- `toLocaleString()`: 返回对象的字符串表示， 该字符串与执行环境的地区对应
- `toString()`: 返回对象的字符串表示
- `valueOf()`: 返回对象的字符串， 数值或布尔值表示

## 3.5 操作符

### 3.5.1 一元操作符

**只能操作一个值的操作符**
- 递增和递减
    - **前置递增/递减**： 变量的值在语句被求值以前改变
    - **后置递增/递减**： 递增/递减操作是在包含他们的语句被求值之后执行
- 一元加和减操作符
    - 对非数值应用一元加操作符， 该操作符会像 `Number()` 转型函数一样对这个值进行转换


### 3.5.2 位操作符
- 位操作符
    - 当对数值应用位操作符时， 后台会发生如下转换过程：
        - 64位数值转换为 32 位
        - 执行位操作
        - 将32位结果返回64位数值
    - 按位非（NOT）**`~`**
        - 执行按位非的结果是返回数值的反码
        - 按位非操作的本质： 操作数的负值减一
    - 按位与（AND）**`&`**
        - 从本质上讲， 按位与的操作就是将两个数值的每一位对其， 对相同位置上的两个数执行 AND 操作、
        - 只在两个数值的对应为都为 `1` 时才返回 `1`, 任何一位是 `0` ， 结果都是 `0`
    - 按位或（OR）**`|`**
        - 有一位为 `1` 就返回 `1` ，两个位都是 `0` 才返回 `0`     
    - 按位异或（XOR）**`^`**
        - 两个数值对应位上只有一个 `1` 时才返回 `1`, 对应位都是 `1` 或 `0` ， 返回 `0`
- 左移（**`<<`**）
    - 将数值的所有位向左移动指定的位数
    - 左移后， 原数值的右侧多出的空位， 会以 `0` 填充, 以便得到一个结果是完整32位的二进制数
    - 左移不会影响操作数的符号位； 如果将 -2 左移 5 位， 结果将是 -64 而非 64
- 有符号的右移（**`>>`**）
    - 将数值向右移动， 但保留符号位
    - 右移后左侧空位由 `符号位的值` 填充
- 无符号右移（**`>>>`**）
    - 将数值的所有32位都向右移动
    - 对正数来说， 与有符号右移相同
    - 对负数来说， 首先， 无符号右移是以 0 来填充空位的； 其次， 无符号右移会把负数的二进制码当成正数的二进制码

### 3.5.3 布尔操作符

- 逻辑非 ： **`!`**
- 逻辑与 ： **`&&`**
    - 逻辑与操作可以应用于任何类型的操作数
    - 在有一个操作数不是布尔值的情况下， 逻辑操作不一定返回布尔值， 他遵循以下规则：
        - 如果第一个操作数是对象， 则返回第二个操作数
        - 如果第二个操作数是对象， 则只有在第一个操作数的求值结果为 `true` 的情况下才会返回该对象
        - 如果两个操作数都是对象， 则返回第二个操作数
        - 如果有一个操作数是 `null` ，返回 `null`
        - 如果有一个操作数是 `NaN` , 则返回 `NaN`
        - 如果有一个操作数是 `undefined` , 则返回 `undefined` 
    - 逻辑与操作属于**短路操作符**, 即如果第一个操作能够决定结果， 那么就不会对第二个操作数求值
- 逻辑或： **`||`**
    - 与逻辑与相似， 如果有一个操作数不是布尔值， 逻辑或也不一定返回布尔值， 遵循以下规则：
        - 如果第一个操作数是对象， 则返回第一个操作数
        - 如果第一个操作数求值结果为 `false` ， 则返回第二个操作数
        - 如果两个操作数都是对象， 则返回第一个操作数
        - 如果两个操作数都是 `null` ， 则返回 `null`
        - 如果两个操作数都是 `NaN` ， 则返回 `NaN`
        - 如果两个操作数都是 `undefined` ， 则返回 `undefined`
    - 与逻辑与相似， 逻辑或也是**短路操作符**， 如果第一个操作数的结果为 `true` ， 就不会对第二个操作数进行求值

### 3.5.4 乘性操作符

ECMAScript 定义了3个乘性操作符， **乘法**， **除法**和**求模**

- 乘法（**`*`**）
    - 如果有一个数是 `NaN` ， 则结果是 `NaN`
    - 如果是 `Infinity` 与 `0` 相乘， 则结果是 `NaN`
    - `Infinity` 与非零数相乘， 结果是 `+Infinity` / `-Infinity`
    - `Infinity` 与 `Infinity` 相乘， 结果是 `Infinity`
    - 如果有一个操作数不是数值， 则先调用 `Number()` 再进行求值
- 除法（**`/`**）
    - 如果有一个数是 `NaN` ， 则结果是 `NaN`
    - 如果是 `Infinity` 被 `Infinity` 除， 则结果是 `NaN`
    - 如果是 `0` 被 `0` 除， 则结果是 `NaN`
    - 如果是非零的有限数被 `0` 除， 则结果是 `+Infinity` 或 `-Infinity`
    - 如果有一个操作数不是数值， 则先调用 `Number()` 再进行求值
- 求模（**`%`**）
    - 如果被除数是有限大的数值而除数是0， 则结果是 `NaN`
    - 如果是 `Infinity` 被 `Infinity` 除， 结果是 `NaN`
    - **如果被除数是有限大的数值，而除数是无穷大的数值， 则结果是被除数** ： `x % Infinity = x`

### 3.5.5 加性操作符

**略**

### 3.5.6 关系操作符

与 ECMAScript 中的其他操作符一样， 当关系操作符的操作数使用了非数值时， 也要进行数据转换或完成某些奇怪的操作， 以下是相应的规则
- 如果两个操作数都是数值， 进行数值比较
- 如果两个操作符都是字符串， 则比较字符串对应的字符串编码值
- 如果一个操作数是数值， 则将另一个转换为一个数值， 然后执行比较
- 如果一个操作符时对象， 则调用这个对象的`valueOf()`方法， 如果没有 `valueOf()` 则调用 `toString()`, 再进行比较
- 如果一个操作数是布尔值， 则先将其转换为数值再进行比较

在比较字符串时， 实际上比较的是两个字符串中对应位置的每个字符的字符编码值，经过这么一番比较之后， 再返回一个布尔值；

根据规则， 任何操作数与 `NaN` 进行关系比较， 结果都是 `false`

### 3.5.7 相等操作符

`ECMAScript` 提供了两组操作符：**相等和不相等**--先转换再比较， **全等和不全等**--仅比较而不转换

**相等和不相等**：

- **相等和不相等** 在 **转换不同数据类型** 时， 遵循下列基本规则
    - 如果有一个操作数是 **布尔值** ，则在比较相等性前先将其转换为**数值**--- `false` -> `0`, `true` -> `1`
    - 如果一个操作数是 **数值** ， 另一个操作数是 **字符串** ， 在比较前先将字符串转换为数值
    - 如果一个操作数是 **对象** ， 另一个不是， 则调用对象的 `valueOf()` 方法， 再进行比较
- **相等和不相等** 在 **进行比较** 时， 遵循下列基本规则
    - `null` 和 `undefined` 是相等的
    - 比较相等性前， 不能将 `null` 和 `undefined` 转换为其他值
    - 如果有一个操作数是 `NaN` ， 则相等操作符返回 `false` ， 不相等返回 `true（即使两个都是` `NaN` ， 也不相等）
    - 如果两个操作数都是对象， 则比较他们是不是同一个对象， 如果两个操作数都指向同一个对象， 则返回 `true`

**全等和不全等**

除了在比较前不转换操作数之外， 全等和不全等操作符与 相等和不相等操作符 没有什么区别；
```
null == undefined       // true
null === undefined      // false
```

### 3.5.8 条件操作符

即三元表达式：
```
variable = boolean_expression ? true_value : false_value;
```
### 3.5.9 赋值操作符

**略**

### 3.5.10 逗号操作符
逗号操作符多用于声明多个变量：
```
var num1=1, num2=2, num3=3;
```

## 3.6 语句

### 3.6.1 if语句

**略**

### 3.6.2 do-while语句
`do-while` 是一种 后测试循环语句， 即只有在循环体中的代码执行以后， 才会测试出口条件；换句话说， 在对条件表达式求值之前， 循环体内的代码至少会被执行一次

```
do {
    statement();
} while (expression);

// eg:
var i = 0;
do {
    i += 2;
} while (i < 10);
alert(i);
```

### 3.6.3 while语句

while语句属于**前测试循环语句**

### 3.6.4 for语句
**略**

### 3.6.5 for-in语句

`for-in` 语句是一种精准的迭代语句， 可以用来枚举对象的属性。 以下是 `for-in` 语句的语法：
```
for (property in expression) statement
```
下面是一个示例：
```
for (var propName in window) {
    document.write(propName)
}
```

如果要迭代对象的变量值为 `null` 或 `undefined` ， `for-in` 语句会抛出错误。 `ECMAScript 5` 更正了这一行为， 这种情况不抛出错误， 而只是不执行

### 3.6.6 label语句

语法：
```
label: statement
```
下面是一个示例：
```
start: for(var i=0; i<10; i++>){
    alert(i)
}
```

### 3.6.7 break和continue语句

**略**

### 3.6.8 with语句
with 语句的作用是将代码的作用域设置到一个特定的对象中，语法如下：
```
with (expression) statement;
```
定义 with 语句的主要目的是为了简化多次编写同一个对象的工作， 如下例子所示：
```
var qs = location.search.substring()
var hostname = location.hostname
var url = location.href

// 使用with：
with (location) {
    var qs = search.substring()
var hostname = hostname
var url = href
}
```

### 3.6.9 switch 语句

**略**

## 3.7 函数

### 3.7.1 理解函数

ECMAScript 函数不介意传递进来多少个函数， 也不在乎传进来参数是什么数据类型； 也就是说， 即便你定义的函数只接收 2 个参数， 在调用时也未必一定要传递 2 个参数， 可以传递 1 个， 3个甚至不传递；

之所以会这样， 是因为 ECMAScript 中的参数在内部是用一个数组来表示的； 在函数体内， 可以通过`arguments`对象来访问这个参数数组；

### 3.7.2 没有重载

`ECMAScript` 函数不能像传统意义上那样实现重载；

在其他语言（如 Java ）中， 可以为一个函数编写两个定义， 只要这两个定义的**签名**（接收参数的类型 和 数量）不同即可

如果在 `ECMAScript` 中定了了2个同名函数， 则该名字只属于后定义的函数（后者覆盖前者）

## 3.8 小结
- `ECMAScript` 中的基本数据类型包括 `Null`, `Undefined`, `String`, `Number`, `Boolean`
- 与其他语言不同， `ECMAScript` 没有为整数和浮点数值分别定义不同数据类型
- `ECMAScript` 中也有一种复杂的数据类型， 即 `Object` 类型，该类型是这门语言中所有对象的基础类型
- 严格模式为这门语言中容易出错的地方施加了限制
- `ECMAScript` 提供了很多与 C 及其他类 C语言中相同的基本操作符，包括算术操作符、布尔操作 符、关系操作符、相等操作符及赋值操作符等。 
- `ECMAScript` 从其他语言中借鉴了很多流控制语句，例如 `if` 语句、`for` 语句和 `switch` 语句等。
- `ECMAScript` 中的函数与其他语言中的函数有诸多不同之处。 
- 无须指定函数的返回值，因为任何 `ECMAScript` 函数都可以在任何时候返回任何值。 
- 实际上，未指定返回值的函数返回的是一个特殊的 `undefined` 值。 
- `ECMAScript` 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式 传递的。 
- 可以向 `ECMAScript` 函数传递任意数量的参数，并且可以通过 `arguments` 对象来访问这些参数。

- 由于不存在函数签名的特性，`ECMAScript`函数不能重载