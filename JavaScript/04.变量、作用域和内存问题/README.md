# 4. 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

`ECMAScript`变量可能包含两种不同数据类型的值： **基本类型值** 和 **引用类型值**

在第三章讨论了5种基本数据类型， 这五种基本数据类型是 **按值访问** 的

**引用类型的值** 是保存在内存中的对象， 与其他语言不同， JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。 在操作对象时， 实际上是在操作 **对象的引用** 而不是实际的对象（这种说法不严密， 当复制保存着对象的某个变量时， 操作的是对象的引用， 但在为对象添加属性时， 操作的是实际的对象）

### 4.1.1 动态的属性

- 对于引用类型， 可以为其添加属性和方法；
- 但是， 不能给基本类型的值添加属性， 尽管这样做不会导致任何错误
```
var name = "Mike";
name.age = 27;
alert(name.age);        // undefined
```

### 4.1.2 复制变量值
- 如果从一个一个变量向另一个变量复制**基本类型**的值， 会在变量对象上创建一个新值， 然后把该值复制到为新变量分配的位置上
- 当从一个变量向另一个变量复制**引用型**的值时， 同样也会将储存在变量对象中的值复制一份放到为新变量分配的空间中， 不同的是， 这个值的副本实际上是一个指针， 指向存储在堆中的一个对象
    - 复制后， 两个变量实际上引用同一个对象， 改变其中一个变量会影响另一个变量

### 4.1.3 传递参数

`ECMAScript` 中所有函数的参数都是 **按值传递** 的。 也就是说， 把函数外部的值复制给函数内部的参数， 就和把值从一个变量复制到另一个变量一样。

!! 访问变量有按值和按引用， 而参数只能按值传递；
- 在向参数传递 **基本类型** 的值时， 被传递的值会被复制给一个局部变量（即命名参数， 或者用 `ECMAScript` 的概念来说， 就是 `arguments` 对象中的一个元素）
- 在向参数传递 **引用类型** 的值时， 会把这个值 **在内存中的地址** 复制给一个局部变量， 因此这个局部变量的变化会反映在函数的外部

```
function setName(obj) {
    obj.name = "张三";
}

var person = new Object();
setName(person);
alert(person.name);     // "张三"
```
在上述代码段的函数内部， `obj` 和 `person` 引用的是同一个对象， 在函数内为 `obj` 添加了属性， 在函数外部的 `person` 也将有所反应; 这里， 很多开发者错误地认为： 在局部作用域中修改的全局对象会在全局作用域中反映出来， 就说明参数是按引用传递的。以下代码段可证明对象是按值传递的：
```
function setName(obj) {
    obj.name = "张三";
    obj = new Object();
    obj.name = "李四";
}
var person = new Object();
setName(person);
alert(person.name);     // "张三"
```
与前一个代码段不同， 函数内部给 `obj` 设置 `name` 属性后， 又将一个新对象赋给变量 `obj` ， 同时将其 `name` 属性设置成其他值， 如果是 **按引用** 传递的， 那么 `person` 变量的引用会自动被修改为指向函数内部 `new Object()` 的对象， 访问 `person.name` 应该得到 '李四'， 而这里依旧是 '张三' ；

实际上， 当在函数背部重写 `obj` 时， 这个变量引用的就是一个局部对象了。 而这个局部对象会在函数执行完毕后立即被销毁.